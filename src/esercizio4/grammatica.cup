package esercizio4;
import java_cup.runtime.*;
import esercizio4.visitor.*;

parser code {:
	Scanner scanner;
	GrammaticaCup(Scanner s, String c){ super(s); this.scanner = s;}
:};

action code {:
	private VisitableNode<String> buildNode(String type, VisitableNode<String>... children){
		VisitableNode<String> node = new VisitableNode<String>(type, null);
		for(int i = 0; i < children.length; i++){
			node.addChild(children[i]);
		}
		return node;
	}
	
	private VisitableNode<String> buildNodeWithValue(String type, String value){
		return new VisitableNode<String>(type, value);
	}
:};


scan with {:
	Symbol next = scanner.next_token();
	//System.out.println(Wrapper.getClassName(next.sym));
	return next;
:};

/*Terminali*/
terminal String    	LPAR, RPAR, MINUS, PROGRAM, IDENTIFIER, INSTRUCTION_SEPARATOR, END_PROGRAM, VAR, PROCEDURE, 
					INTEGER, BOOLEAN, BEGIN, WRITE, READ, IF, THEN, WHILE, DO, END, ASSIGN, RELATIONAL_OPERATOR, ADDING_OPERATOR, 
					MULTIPLYING_OPERATOR, NOT, TRUE, FALSE, SEPARATOR, ELSE, INTEGER_CONSTANT, STRING_CONSTANT, CHARACTER_CONSTANT;

/*Non Terminali*/
nonterminal VisitableNode<String>	program_nt, block, variable_declaration_part, procedure_declaration_part, statement_part, variable_declaration,
									procedure_declaration, simple_block, compound_statement, statement, simple_statement, structured_statement, assignment_statement,
									read_statement, write_statement, expression, output_value, if_statement, while_statement, simple_expression, constant;

/*Non Terminali di supporto */
nonterminal	VisitableNode<String> variable_declaration_list, separator_identifier, instruction_separator_statement, separator_input_variable, separator_output_value;
			
nonterminal String	constant_identifier, variable_identifier, variable, procedure_identifier, simple_type, input_variable, adding_operator, procedure_statement;

/*Precendenze*/
precedence left ADDING_OPERATOR;
precedence left MULTIPLYING_OPERATOR;
precedence left ASSIGN, READ, WRITE;
precedence left ELSE;
precedence left RELATIONAL_OPERATOR;
precedence right MINUS;

program_nt ::=	PROGRAM IDENTIFIER INSTRUCTION_SEPARATOR block END_PROGRAM
				;
				
block ::=	variable_declaration_part procedure_declaration_part statement_part 
			;

variable_declaration_part ::=	VAR variable_declaration INSTRUCTION_SEPARATOR variable_declaration_list
								|
								/* epsilon */
								;
								
variable_declaration_list ::=	variable_declaration INSTRUCTION_SEPARATOR variable_declaration_list
								|
								/* epsilon */
								;

variable_declaration ::=	IDENTIFIER separator_identifier simple_type
							;
							
separator_identifier ::=	SEPARATOR IDENTIFIER separator_identifier
							|
							/* epsilon */
							;

simple_type ::=	INTEGER | BOOLEAN ;

procedure_declaration_part ::=	procedure_declaration INSTRUCTION_SEPARATOR procedure_declaration_part
								|
								/* epsilon */
								;

procedure_declaration ::=	PROCEDURE IDENTIFIER INSTRUCTION_SEPARATOR simple_block
							;
							
simple_block ::=	variable_declaration_part statement_part ;

statement_part ::=	compound_statement ;

compound_statement ::=	BEGIN statement instruction_separator_statement END
						;
						
instruction_separator_statement ::=	INSTRUCTION_SEPARATOR statement instruction_separator_statement
									|
									/* epsilon */
									;
									
statement ::=	simple_statement | structured_statement ;

simple_statement ::=	assignment_statement | read_statement | procedure_statement | write_statement ;

assignment_statement ::=	variable:id ASSIGN expression;

read_statement ::=	READ LPAR input_variable separator_input_variable RPAR ;

separator_input_variable ::=	SEPARATOR input_variable separator_input_variable
								|
								/* epsilon */
								;
								
input_variable ::= variable:v {: RESULT = v;:};

procedure_statement ::= procedure_identifier:p_id {: RESULT = p_id; :} ;

procedure_identifier ::= IDENTIFIER:id {: RESULT = id; :} ;

write_statement ::= WRITE LPAR output_value separator_output_value RPAR ;

separator_output_value ::=	SEPARATOR output_value separator_output_value
							|
							/* epsilon */
							;

output_value ::= expression ;

structured_statement ::= compound_statement | if_statement | while_statement ;

if_statement ::=	IF expression THEN statement
					|
					IF expression THEN statement ELSE statement %prec ELSE
					;
					
while_statement ::=	WHILE expression DO statement ;

expression ::=	simple_expression:node {: RESULT = buildNode("SimpleExprOp", node); :}
				|
				simple_expression:node_1 RELATIONAL_OPERATOR:attr simple_expression:node_2 {:
					VisitableNode<String> relop = new VisitableNode<String>("RELATIONAL_OPERATOR", attr);
					RESULT = buildNode("RelationalOp", relop, node_1, node_2);
				:}
				;
				
simple_expression ::=	simple_expression:node_1 adding_operator:attr simple_expression:node_2 {:
							VisitableNode<String> add_op = new VisitableNode<String>("ADDING_OPERATOR", attr);
							RESULT = buildNode("AddOp", add_op, node_1, node_2);
						:}
						|
						simple_expression:node_1 MULTIPLYING_OPERATOR:attr simple_expression:node_2 {:
							VisitableNode<String> mul_op = new VisitableNode<String>("MULTIPLYING_OPERATOR", attr);
							RESULT = buildNode("MulOp", mul_op, node_1, node_2);
						:}
						|
						variable:var {: RESULT = buildNode("VarOp", new VisitableNode<String>("ID", var)); :}
						|
						constant:node {: RESULT = buildNode("ConstOp", node); :}
						|
						LPAR expression:exp RPAR {: RESULT = buildNode("ExprOp", exp); :}
						|
						NOT expression:exp {: RESULT = buildNode("NotOp", exp); :}
						|
						MINUS simple_expression:exp {: RESULT = buildNode("UnaryMinusOp", exp); :} %prec MINUS 
						;
						
adding_operator ::=	ADDING_OPERATOR:v {: RESULT = v; :}
					|
					MINUS:v {: RESULT = "-"; :}
					;
						
variable ::= variable_identifier:id {:RESULT = id;:};

variable_identifier ::= IDENTIFIER:id  {:RESULT = id;:};

constant ::= INTEGER_CONSTANT:c {: RESULT = buildNodeWithValue("INTEGER_CONSTANT", c);; :}
			 | 
			 STRING_CONSTANT:c  {: RESULT = buildNodeWithValue("STRING_CONSTANT", c);; :}
			 | 
			 CHARACTER_CONSTANT:c {: RESULT = buildNodeWithValue("CHARACTER_CONSTANT", c);; :}
			 | 
			 constant_identifier:c {: RESULT = buildNodeWithValue("BOOLEAN_CONSTANT", c); :} ;

constant_identifier ::=	TRUE {: RESULT = Wrapper.getClassName(sym.TRUE); :} 
						|
						FALSE {: RESULT = Wrapper.getClassName(sym.FALSE); :};
